## JS
### <a name="1"></a>1. Типы данных JS?

 JavaScript определяет 7 типов данных:
•	null
•	undefined
•	boolean
•	string
•	number
•	object
•	symbol (добавлен в ES6)
Все типы данных кроме объектов (objects) — примитивные.

Все типы данных в JavaScript, кроме объектов, являются иммутабельными (значения не могут быть модифицированы, а только перезаписаны новым полным значением). Например, в отличии от C, где строку можно посимвольно корректировать, в JavaScript строки пересоздаются только полностью. Значения таких типов называются «примитивными значениями». Примитивы копируются полностью, объекты и массивы (не тип данных) по ссылке.


### <a name="2"></a>2. Что такое DOM?

DOM или Document Object Model (объектная модель документа) — это прикладной программный интерфейс (API) для работы с HTML и XML документами. Когда браузер первый раз читает («парсит») HTML документ, он формирует большой объект, действительно большой объект, основанный на документе — DOM. DOM представляет собой древовидную структуру (дерево документа). DOM используется для взаимодействия и изменения самой структуры DOM или его отдельных элементов и узлов.

### <a name="3"></a>3. Что такое поднятие (Hoisting)?

Поднятие — подъем переменной или функции в глобальную или функциональную области видимости.
Для того, чтобы понять, что такое Hoisting, необходимо разобраться с тем, что представляет собой контекст выполнения.

Контекст выполнения — это среда, в которой выполняется код. Контекст выполнения имеет две фазы — компиляция и собственно выполнение.

Компиляция. В этой фазе функциональные выражения и переменные, объявленные с помощью ключевого слова «var», со значением undefined поднимаются в самый верх глобальной (или функциональной) области видимости (как бы перемещаются в начало нашего кода. Это объясняет, почему мы можем вызывать функции до их объявления — прим. пер.).

Выполнение. В этой фазе переменным присваиваются значения, а функции (или методы объектов) вызываются или выполняются.

Запомните: поднимаются только функциональные выражения и переменные, объявленные с помощью ключевого слова «var». Обычные функции и стрелочные функции, а также переменные, объявленные с помощью ключевых слов «let» и «const» не поднимаются.

### <a name="4"></a>4. Что такое область видимости (Scope)?

Область видимости — это место, где (или откуда) мы имеем доступ к переменным или функциям. JS имеет три типа областей видимости: глобальная, функциональная (локальная) и блочная (ES6).

Глобальная область видимости — переменные и функции, объявленные в глобальном пространстве имен, имеют глобальную область видимости и доступны из любого места в коде.

### <a name="5"></a>5. Отличие for...of от for...in в javascript?

Оба оператора, и for...in и for...of производят обход объектов. Разница лишь в том, как они это делают.
Оператор for...of выполняет обход по элементам коллекций (иначе говоря, итерируемых объектов, например, Array, Map, Set, String, arguments, DOM коллекций и т.д.), вызывая на каждом шаге итерации значение, а не ключ.

for...in
Цикл for...in проходит через перечисляемые свойства объекта. Он пройдёт по каждому отдельному элементу, вызывая на каждом шаге ключ. Цикл for...in проходит по свойствам в произвольном порядке, поэтому его не следует использовать для Array.

```
var obj = {a:1, b:2, c:3};

for (var prop in obj) {
  console.log("obj." + prop + " = " + obj[prop]);
}

// Выведет:
// "obj.a = 1"
// "obj.b = 2"
// "obj.c = 3"
```

### <a name="6"></a>6. ECMAScript?

Проще говоря, ECMAScript — стандарт, а JavaScript — самая популярная реализация этого стандарта.
Версия ES6/ES2015 вышла в июне 2015 года.

### <a name="7"></a>7. Замыкания (closure)?

Замыкание (closure) представляют собой конструкцию, когда функция, созданная в одной области видимости, запоминает свое лексическое окружение даже в том случае, когда она выполняет вне своей области видимости.
Замыкание технически включает три компонента:
•	внешняя функция, которая определяет некоторую область видимости и в которой определены некоторые переменные - лексическое окружение
•	переменные (лексическое окружение), которые определены во внешней функции
•	вложенная функция, которая использует эти переменные
```
function outer(){       // внешняя функция
    var n;              // некоторая переменная
    return inner(){     // вложенная функция
        // действия с переменной n
    }
}
```
Рассмотрим замыкания на простейшем примере:
```
function outer(){
    let x = 5;
    function inner(){
        x++;
        console.log(x);
    };
    return inner;
}
let fn = outer();   // fn = inner, так как функция outer возвращает функцию inner
// вызываем внутреннюю функцию inner
fn();   // 6
fn();   // 7
fn();   // 8
```
Здесь функция outer задает область видимости, в которой определены внутренняя функция inner и переменная x. Переменная x представляет лексическое окружение для функции inner. В самой функции inner инкрементируем переменную x и выводим ее значение на консоль. В конце функция outer возвращает функцию inner.
Далее вызываем функцию outer:
let fn = outer();
Поскольку функция outer возвращает функцию inner, то переменная fn будет хранить ссылку на функцию inner. При этом эта функция запомнила свое окружение - то есть внешнюю переменную x.
Далее мы фактически три раза вызываем функцию Inner, и мы видим, что переменная x, которая определена вне функции inner, инкрементируется:
```
fn();   // 6
fn();   // 7
fn();   // 8
```
То есть несмотря на то, что переменная x определена вне функции inner, эта функция запомнила свое окружение и может его использовать, несомотря на то, что она вызывается вне функции outer, в которой была определена. В этом и суть замыканий.

### <a name="8"></a>8. Самовызывающиеся функции?

Обычно определение функции отделяется от ее вызова: сначала мы определяем функцию, а потом вызываем. Но это необязательно. Мы также можем создать такие функции, которые будут вызываться сразу при определении. Такие функции еще называют Immediately Invoked Function Expression (IIFE).

```
(function(){
    console.log("Привет мир");
}());
 
(function (n){
     
    var result = 1;
    for(var i=1; i<=n; i++)
        result *=i;
    console.log("Факториал числа " + n + " равен " + result);
}(4));
```
Подобные функции заключаются в скобки, и после определения функции идет в скобках передача параметров.


### <a name="9"></a>9. Eventloop?
Поток выполнения в браузере, равно как и в Node.js, основан на событийном цикле.
Понимание работы событийного цикла важно для оптимизаций, иногда для правильной архитектуры.
В этой главе мы сначала разберём теорию, а затем рассмотрим её практическое применение.
Событийный цикл
Идея событийного цикла очень проста. Есть бесконечный цикл, в котором движок JavaScript ожидает задачи, исполняет их и снова ожидает появления новых.
Общий алгоритм движка:
1.	Пока есть задачи:

o	выполнить их, начиная с самой старой
2.	Бездействовать до появления новой задачи, а затем перейти к пункту 1

Макрозадачи и Микрозадачи

Помимо макрозадач, описанных в этой части, существуют микрозадачи, упомянутые в главе Микрозадачи.
Микрозадачи приходят только из кода. Обычно они создаются промисами: выполнение обработчика .then/catch/finally становится микрозадачей. Микрозадачи также используются «под капотом» await, т.к. это форма обработки промиса.
Также есть специальная функция queueMicrotask(func), которая помещает func в очередь микрозадач.
Сразу после каждой макрозадачи движок исполняет все задачи из очереди микрозадач перед тем, как выполнить следующую макрозадачу или отобразить изменения на странице, или сделать что-то ещё.
Например:
```
setTimeout(() => alert("timeout"));

Promise.resolve()
  .then(() => alert("promise"));

alert("code");
```
Какой здесь будет порядок?
1.	code появляется первым, т.к. это обычный синхронный вызов.
2.	promise появляется вторым, потому что .then проходит через очередь микрозадач и выполняется после текущего синхронного кода.
3.	timeout появляется последним, потому что это макрозадача.

![Eventloop pic](/pics/eventloop.png)

### <a name="10"></a>10. Call/apply/bind?


call - вызов функции с подменой контекста - this внутри функции. Пример:

```
function f(arg) {
    alert(arg);
    alert(this);
}

f('abc');             // abc, [object Window]

f.call('123', 'abc'); // abc, 123
```

apply - вызов функции с переменным количеством аргументов и с подменой контекста. Пример:
```
function f() {
    alert(this);
    for (var i = 0; i < arguments.length; i++) {
        alert(arguments[i]);
    }
}

f(1, 2, 3);                   // [object Window], 1, 2, 3

f.apply('abc', [1, 2, 3, 4]); // abc, 1, 2, 3, 4
```


bind - создаёт "обёртку" над функцией, которая подменяет контекст этой функции. Поведение похоже на call и apply, но, в отличие от них, bind не вызывает функцию, а лишь возвращает "обёртку", которую можно вызвать позже. Пример:

```
function f() {
    alert(this);
}

var wrapped = f.bind('abc');

f();         // [object Window]
wrapped();   // abc
```

Также bind умеет подменять не только контекст, но и аргументы функции, осуществляя каррирование:
```
function add(a, b) {
    return a + b;
}

var addOne = add.bind(null, 1);

alert(add(1, 2));   // 3

alert(addOne(2));   // 3

```


### <a name="11"></a>11. Стрелочные функции
Стрелочные функции:

•	Не имеют this. Берёт внешний контекст.
•	Не имеют arguments.
•	Не могут быть вызваны с new. 
Как следствие того, что стрелочные функции не имеют собственного this они не могут быть использованы для создания объектов.Если ты попытаешься вызвать стрелочную функцию с использованием ключевого слова new, JS кинет исключение: ... is not a constructor.
•	У них также нет super.

### <a name="12"></a>12. Копирование данных в JS

Примитивные типы копируются по значению.
Объекты и массивы копируют лишь ссылки.
Скопировать объект, если нет других вложенных объектов
ES6 spread operator
```
let clone = {...clonedObject};
```
old way
```
let clone = Object.assign({}, user);
```
Мы можем реализовать глубокое клонирование, используя рекурсию. Или, чтобы не изобретать велосипед, использовать готовую реализацию — метод _.cloneDeep(obj) из JavaScript-библиотеки lodash.
Копия массива без глубокой копии

ES6 spread operator
```
const oldArray = ["1", "2", "3"];
const newArray = [...oldArray];
```
old way
```
var oldArray = ["a", "b", "c"];
var newArray = oldArray.slice();
```

### <a name="14"></a>14. null vs undefined

null - значение переменной присвоено, пустота.
undefined - переменная объявлена, но ничего не присвоено.

### <a name="15"></a>15. Регулярные выражения (Regular Expressions (regexp))

Регулярные выражения - это шаблоны, используемые для сопоставления последовательностей символов в строках. В JavaScript регулярные выражения также являются объектами. Эти шаблоны используются в методах exec и test объекта RegExp, а также match, replace, search и split объекта String.

«Длинный» синтаксис:
```
regexp = new RegExp("шаблон", "флаги");
```
…И короткий синтаксис, использующий слеши "/":
```
regexp = /шаблон/; // без флагов
regexp = /шаблон/gmi; // с флагами gmi (будут описаны далее)
```
Слеши /.../ говорят JavaScript о том, что это регулярное выражение. Они играют здесь ту же роль, что и кавычки для обозначения строк.

Регулярное выражение regexp в обоих случаях является объектом встроенного класса RegExp.

Основная разница между этими двумя способами создания заключается в том, что слеши /.../ не допускают никаких вставок переменных (наподобие возможных в строках через ${...}). Они полностью статичны.

Слеши используются, когда мы на момент написания кода точно знаем, каким будет регулярное выражение – и это большинство ситуаций. А new RegExp – когда мы хотим создать регулярное выражение «на лету» из динамически сгенерированной строки.

### <a name="16"></a>16. Лексическое окружение (LexicalEnvironment)

Каждый раз, когда в программе вызывается функция, внутри интерпретатора создается специальный словарь LexicalEnvironment (лексическое окружение), привязанный к этому вызову. Все определения констант, переменных и прочего внутри функции автоматически записываются в словарь. Имя определения (идентификатор, то есть имя константы, переменной и так далее) становится ключом, а значение определения становится значением в словаре. К таким определениям относятся аргументы, константы, функции, переменные и т.д. Лексическое окружение — это хранилище для данных в памяти и механизм для извлечения этих данных при обращении.
В примере ниже в комментариях показано состояние словаря перед выполнением каждой строчки кода. Не забывайте, что наполнение словаря происходит при вызове функции, а не при определении.
```
const showWarning = (field) => {
  // LexicalEnvironment = { field: 'email' }
  const warning = `verify your ${field}, please`;
  // LexicalEnvironment = { warning: 'verify your email, please', field: 'email' }
  console.log(warning);
}

showWarning('email'); // => verify your email, please
```
Код console.log(warning) активизирует поиск значения идентификатора warning в лексическом окружении.
В процессе выполнения функции значения переменных могут меняться, что сразу же отражается в лексическом окружении. После выполнения функции её лексическое окружение уничтожается, а занятая им память освобождается.

### <a name="17"></a>17. Map и Set

Сейчас мы знаем о следующих сложных структурах данных:
•	Объекты для хранения именованных коллекций.
•	Массивы для хранения упорядоченных коллекций.
Но этого не всегда достаточно для решения повседневных задач. Поэтому также существуют Map и Set.
Map
Map – это коллекция ключ/значение, как и Object. Но основное отличие в том, что Map позволяет использовать ключи любого типа.
Методы и свойства:
•	new Map() – создаёт коллекцию.
•	map.set(key, value) – записывает по ключу key значение value.
•	map.get(key) – возвращает значение по ключу или undefined, если ключ key отсутствует.
•	map.has(key) – возвращает true, если ключ key присутствует в коллекции, иначе false.
•	map.delete(key) – удаляет элемент по ключу key.
•	map.clear() – очищает коллекцию от всех элементов.
•	map.size – возвращает текущее количество элементов.
Например:
```
let map = new Map();

map.set("1", "str1");    // строка в качестве ключа
map.set(1, "num1");      // цифра как ключ
map.set(true, "bool1");  // булево значение как ключ

// помните, обычный объект Object приводит ключи к строкам?
// Map сохраняет тип ключей, так что в этом случае сохранится 2 разных значения:
alert(map.get(1)); // "num1"
alert(map.get("1")); // "str1"

alert(map.size); // 3
```
Как мы видим, в отличие от объектов, ключи не были приведены к строкам. Можно использовать любые типы данных для ключей.
Map может использовать объекты в качестве ключей.

## React

### <a name="1"></a>1. Что такое React?
React — это декларативная, эффективная и гибкая JavaScript библиотека для создания пользовательских интерфейсов. Она позволяет вам собирать сложный UI из маленьких изолированных кусочков кода, называемых «компонентами».
Из схемы разделения данных MVС (Model-View-Controller) React выполняет роль элемента V-View.

### <a name="2"></a>2. Особенности React как фреймворка, зачем он нужен?

React нужен для создания SPA (single page application).
Особенности:
1. Виртуальный DOM (Virtual DOM). Оптимизирует рендер элементов, исключает лишний ререндер DOM при обновлении состояния.
2. Декларативность. описываем различные состояния комонента в виде стейта.
3. Компонентный подход. React основан на компонентах, это ещё одна ключевая особенность библиотеки. Каждый компонент возвращает часть пользовательского интерфейса со своим состоянием. Объединяя компоненты, программист создаёт завершённый интерфейс веб-приложения.
4. Универсальность
 , , , JSX
### <a name="3"></a>3. В чем разница между элементом и компонентом React.JS?

1.	Если просто: элемент – это то, что вы хотите видеть на экране.
2.	Если не так просто: элемент – объектное представление некоторого пользовательского интерфейса.

С компонентом все иначе. Это класс или функция, что может принимать данные и возвращать элементы


